[[chapter4]]

== Use case examples

=== Basic non-virtualized system

==== Overview

==== Secure and Verified Boot

==== Isolation model

==== Device access control

==== Sealing

==== Attestation


=== Basic virtualized system

==== Overview

==== Isolation model

==== Device access control

==== Sealing

==== Attestation


=== Global Platform TEE

==== Overview

[caption="Figure {counter:image}: ", reftext="Figure {image}"]
[title= "Global platform TEE use cases"]
image::img_ch4_gp-tee.png[]

https://globalplatform.org/[Global platform] defines technical standards, interface specifications and programming models, open source firmware, and certification programmes for _trusted execution environments (TEE)_. 

A TEE is an isolated environment on a Hart providing security services to other software on the same Hart. For example:

* Payment clients
* DRM clients and content protection
* Secure storage
* User identity management
* Attestation services

The TEE model divides software into physically isolated domains:

* Normal domain +
Typically hosting a _rich OS_ (for example, RTOS or Linux), and user applications. 
* TEE domain +
Hosts a _TEE OS_ (domain security manager) and _trusted applications (TA)_. 
* Root domain +
Hosts RoT firmware, including a secure monitor

The TEE OS is primarily responsible for isolation of TA, and for providing root of trust services, within the TEE domain.

The OS in normal domain typically controls scheduling on the Hart. To interact with TA services, the OS in normal mode interacts with the TEE OS through the secure monitor in root domain. 

The secure monitor is responsible for context switching and isolation across domain boundaries. 

For the purpose of this specification, TEE deployment models can be separated as:

* Static partition TEE +
A single TEE provides security services to normal domain. TA are typically installed at boot by RoT FW and TEE OS, though Global Platforms does also define protocols for installation of TA at runtime. System configuration and resource allocation can be mostly static, making the system more deterministic. +
 +
_Use case examples:_ edge devices and IoT, automation, and automotive. 
* Virtualized TEE +
On a virtualized system, TEE can also be virtualized. In this case a _secure partition manager_ in TEE domain is responsible for isolation of multiple TEE guests (for example, an OEM TEE and separate third party TEE). This model can also support more dynamic resource allocation. +
 +
_Use case examples:_ mobile clients, and automotive.

==== Isolation model

A Global Platform TEE requires the following isolation guarantees:

[width=100%]
[%header, cols="5,20"]
|===
| ID#     
| Requirement

| CAT_NNN  
| Root domain MAY access resources assigned to any domain, but SHOULD prevent itself from unintended access to resources assigned to a different domain (privilege escalation).

| CAT_NNN
| No other domains can access resources assigned to Root domain

| CAT_NNN
| Resources assigned to TEE domain MUST NOT be accessible to normal domain

| CAT_NNN
| Resources assigned to normal domain MUST be accessible to normal domain (r/w/x), and to TEE domain (r/w) (default sharing rule)

| CAT_NNN
| Resources assigned to a single TA, or a guest TEE, MUST not be accessible by a different TA, or guest TEE.

|===

The standard GP TEE model prevents sharing memory between TA in TEE domain. Each TA is expected to be a self-contained unit providing a specific security service, either to Normal domain or to other TA. All communications are implemented through secure channels managed by the TEE OS or SPM. 

Processes in Normal domain can share memory assigned to Normal domain when interacting with a TA in TEE world (default sharing rule). Such shared memory can be cached when context switching between Normal and TEE domains.

RISC-V hardware enforced isolation mechanisms can be used as follows to meet those guarantees:

[width=100%]
[%header, cols="5,20"]
|===
| ID#     
| Requirement

| CAT_NNN 
| PMP/ePMP (PMA), or MTT, MUST be used to isolate Root domain from other domains.

| CAT_NNN  
| Supervisor domains MUST be used to enforce isolation between Normal and TEE domains.

|===

See xref:chapter3.adoc#_supervisor_domains[supervisor domains].

For static partition TEE, using PMP/ePMP or PMA with supervisor domains can be sufficient. 

For virtualized TEE, MTT should be used with supervisor domains.

NOTE: MTT can be sufficient for protecting Root domain in the sense that M-mode can enforce that its own resources are never assigned to another domain. PMP/ePMP still add further protections for M-mode, such as the ability to implement temporal isolation boundaries within M-mode (for example, protect early boot code), or to prevent itself from accessing or executing from memory assigned to lower privilege levels (privilege escalation).

[width=100%]
[%header, cols="5,20"]
|===
| ID#     
| Requirement

| CAT_NNN
| For a static partition TEE, sPMP or MMU MUST be used to enforce isolation between TA in TEE domain.
|===

[width=100%]
[%header, cols="5,20"]
|===
| ID#     
| Requirement

| CAT_NNN
| For a virtualized TEE, hypervisor extension MUST be supported

| CAT_NNN
| For a virtualized TEE, MMU MUST be used to enforce isolation between guest TEE, and between TA within a TEE.
|===

==== Root of Trust

See xref:chapter2.adoc#_reference_model[reference model].

[width=100%]
[%header, cols="5,20"]
|===
| ID#     
| Requirement

| CAT_NNN 
| A TEE based system SHOULD implement a HW RoT

|===

==== Authorized boot

See xref:chapter2.adoc#_authorized_software[authorized software].

TEE boot is typically based on:

* Measured and verified local boot (direct or indirect)
* Sealing, to protect TEE production assets

The process can involve multiple stages (layered boot). 

==== Attestation

See xref:chapter2.adoc#_attestable_services[attestable services].

Static partition TEE attestation is typically based on a direct security platform attestation.

[width=100%]
[%header, cols="5,20"]
|===
| ID#     
| Requirement

| CAT_NNN 
a| A direct security platform attestation MUST cover at least: 

* TEE domain
* Root domain
* Boot state of all trusted subsystems

|===

Virtualized TEE attestation can be layered, for performance or separation of concern. For example:

* A security platform attestation, signed by a RoT, covering trusted subsystems, Root domains, and SPM
* Separate guest TEE attestation(s) signed by SPM 

==== Sealing

See xref:chapter2.adoc#_sealing[sealing].

SPM or TEE OS typically provide local trusted storage, key management, and cryptographic services for TA and guest TEE (defined by Global Platform as part of _PSA RoT services_). These services support local sealing of TA or guest TEE assets.

[width=100%]
[%header, cols="5,20"]
|===
| ID#     
| Requirement

| CAT_NNN
| Local sealing for a TA, or a TEE guest, MUST be unique to TEE domain and to a physical instance of a system.

| CAT_NNN
| Local sealing for a TA, or a TEE guest, SHOULD also be unique to the TEE guest or the TA.

| CAT_NNN
| Local sealing MAY be layered.

|===

For example:

* TEE domain unique sealing keys derived by a RoT from a hardware unique key
* TA, or guest TEE, unique sealing keys derived by TEE OS or SPM from a TEE domain unique sealing key

==== Device access control

For the purpose of this specification, a device can be a logical device. A physical device can present one or more logical devices, each with its own (logical) control interface. 

The security guarantees also apply to device initiated accesses, for example DMA and interrupts. 

[width=100%]
[%header, cols="5,20"]
|===
| ID#     
| Requirement

| CAT_NNN
| A static partition TEE MUST use IOPMP to enforce access control rules for devices.

| CAT_NNN
| A virtualized TEE MUST use IOMTT and IOMMU to enforce access control rules for devices assigned to Normal or TEE domains, and SHOULD use IOPMP to enforce access control rules for Root devices.

|===

For a static partition TEE, domain level granularity can be sufficient as device access within TEE and Normal domains is governed by TEE OS and the rich OS respectively. It can be implemented using IOPMP. Policy can be controlled by boot configuration, by a HW or FW RoT.

For a virtualized TEE, IOMTT enforces supervisor domain level access rules (physical isolation). IOMMU enforces guest and TA level access rules (virtualization), supporting device assignment to a guest TEE or a TA.  

NOTE: IOMTT can also be sufficient for protecting Root devices in the sense that M-mode can enforce that its own resources are never assigned to another domain. Use of IOPMP or similar still adds further protections. For example, a system may require that Root devices cannot be used to access memory assigned to Confidential domain.

==== System integration

In the case of a Global Platform TEE system, the number and make-up of supervisor domains can be known, and a simple convention can be used for common identification of Normal, TEE, and Root domains across multiple Harts in a system. 

System integration in this context involves providing _security attributes_ on the interconnect, tagging all transactions (CPU or system agent initiated). 

Possible use cases include:

* Tweaking cryptographic memory protection (uniqueness)
* Driving cache coherent memory subsystems
* Device assignment (IOPMP/IOMTT integration), static or dynamic

For example, the following convention is commonly used in existing ecosystems for domain level granularity:

[width=30%]
[%header, cols="20,10"]
|===
| 
| Security attribute

| TEE domain
| 2'b00

| Normal domain
| 2'b01

| Root domain
| 2'10

| Reserved +
(Confidential domain)
| 2'11

|===

The attributes can be derived, for example, from SDID and privilege level, from PMA, or from MTT dynamic PMA (svpam).

For some use cases security attributes can be extended to reflect finer granularity, for example for cryptographic memory protection. For example, derived from SPM _partition ID_.

=== Confidential computing on RISC-V (CoVE)
==== Overview
[caption="Figure {counter:image}: ", reftext="Figure {image}"]
[title= "Global platform TEE use cases"]
image::img_ch4_cove.png[]

In hosting environments, tenant workloads rely on isolation primitives that are managed by host privileged software. This can lead to a large TCB for tenants which could include, for example, a hypervisor, orchestration services, and host management services. It could also include other tenants exploiting vulnerabilities in complex hosting software.

Confidential compute aims to achieve a minimal and certifiable TCB for _confidential workloads_. 

_CoVE (Confidential VM Extensions)_ https://github.com/riscv-non-isa/riscv-ap-tee/tree/main/specification[specification] defines a confidential compute platform for RISC-V systems, including interfaces and programming models, covering lifecycle management, attestation, resource management and devices assignment, for confidential workloads. It is based on principles defined by https://confidentialcomputing.io/[Confidential Computing Consortium]. Reference firmware for CoVE is being developed as part of the https://riseproject.dev/[Risc-V Software Ecosystem] project.

CoVE is primarily aimed at cloud hosting of confidential workloads. But the underlying isolation model could potentially be used in other use cases, such as some mobile clients or edge devices.

CoVE divides software on a Hart into physically isolated domains:

* Normal domain +
Typically hosting a hypervisor, and normal guests and services. 
* Confidential domain +
Hosts a _TSM_ (domain security manager) and confidential guests.
* Root domain +
Hosts RoT firmware, including a _secure monitor_ 

The TSM is primarily responsible for isolation of confidential workloads, and for providing RoT services, within the confidential domain.

A hypervisor in normal domain typically controls scheduling and resource assignment on the Hart. It interacts with the TSM through the secure monitor in root domain to manage confidential workloads. 

The secure monitor is responsible for context switching and isolation across domain boundaries.

==== Isolation model

Confidential workloads are provided the following isolation guarantees:

[width=100%]
[%header, cols="5,20"]
|===
| ID#     
| Requirement

| CAT_NNN  
| Root domain MAY access resources assigned to any domain, but SHOULD prevent itself from unintended access to resources assigned to a different domain (privilege escalation).

| CAT_NNN
| Resources assigned to Root domain MUST be private to Root domain

| CAT_NNN
| Resources assigned only to Confidential domain MUST not be accessible by Normal domain

| CAT_NNN
| Resources assigned only to Normal domain MUST not be accessible by Confidential domain

| CAT_NNN
| Resources MAY be assigned to both Normal and Confidential domains (sharing by consent).

| CAT_NNN
| Resources assigned to a single confidential workload MUST NOT be accessible by any other confidential workload

| CAT_NNN
| Resources MAY be assigned to multiple confidential workloads (sharing by consent)

|===

RISC-V hardware enforced isolation mechanisms can be used as follows to meet those guarantees:

[width=100%]
[%header, cols="5,20"]
|===
| ID#     
| Requirement

| CAT_NNN 
| PMP/ePMP or MTT MUST be used to isolate Root domain from other domains.

| CAT_NNN  
| Supervisor domains MUST be used to enforce isolation between Normal and Confidential domains.

|===

See xref:chapter3.adoc#_supervisor_domains[supervisor domains].

NOTE: MTT can be sufficient for protecting Root domain in the sense that M-mode can enforce that its own resources are never assigned to another domain. PMP/ePMP still add further protections for M-mode, such as the ability to implement temporal isolation boundaries within M-mode (for example, protect early boot code), or to prevent itself from accessing or executing from memory assigned to lower privilege levels (privilege escalation).

[width=100%]
[%header, cols="5,20"]
|===
| ID#     
| Requirement

| CAT_NNN
| Hypervisor extension MUST be supported

| CAT_NNN
| MMU MUST be used to enforce isolation between confidential guests within Confidential domain.
|===

==== Root of trust

See xref:chapter2.adoc#_reference_model[reference model].

[width=100%]
[%header, cols="5,20"]
|===
| ID#     
| Requirement

| CAT_NNN 
| A CoVE system MUST implement a HW RoT

|===

==== Authorized Boot

See xref:chapter2.adoc#_authorized_software[authorized software].

[width=100%]
[%header, cols="5,20"]
|===
| ID#     
| Requirement

| CAT_NNN 
a| Confidential guests MUST not boot until at least the security platform has been verified:

* TSM in Confidential domain
* Root domain
* Boot state of all trusted subsystems
|===

Boot in a cloud hosting context is typically based on:

* Measured boot of a hosting platform, including Root domain and TSM
* Platform attestation and security provisioning (unsealing) by a remote provisioning system
* Launch and measurement of confidential workloads, only once the system has been unsealed

A _trusted platform module_ (TPM) can be used to measure the security platform.

Measuring confidential guests can be done by TSM in Confidential domain.

The process can involve multiple stages (layered boot). 

==== Attestation

See xref:chapter2.adoc#_attestable_services[attestable services].

Attestation of confidential workloads is typically layered, for performance and separation of concern:

* A security platform attestation, signed by a hardware root of trust
* A confidential workload attestation, signed by TSM

[width=100%]
[%header, cols="5,20"]
|===
| ID#     
| Requirement

| CAT_NNN 
a| A security platform attestation MUST cover at least: 

* TSM
* Root domain
* Boot state of all trusted subsystems

|===

==== Sealing

See xref:chapter2.adoc#_sealing[sealing].

Sealing of confidential workloads is typically based on remote sealing, unsealing assets for a confidential workload following successful attestation by a remote provisioning system. This enables use cases such as:

* Shared assets across multiple instances of a confidential workload (scale or redundancy)
* Unsealing different sets of assets for different users of a service

TSM itself is typically stateless across reset and does not require any sealed assets of its own.

==== Device access control

For the purpose of this specification, a device can be a logical device. A physical device can present more than one logical devices, each with its own (logical) control interface. 

The security guarantees also apply to device initiated accesses, for example DMA and interrupts.

[width=100%]
[%header, cols="5,20"]
|===
| ID#     
| Requirement

| CAT_NNN
| IOMTT and IOMMU MUST be used to enforce access control rules for devices assigned to Normal or Confidential domains.

| CAT_NNN
| IOPMP SHOULD be used to enforce access control rules for Root devices.

| CAT_NNN
| IOPMP and IOMTT configurations MUST only be directly accessible by Root domain.

|===

IOMTT enforces supervisor domain level access rules (physical isolation). IOMMU enforces guest and TA level access rules (virtualization), supporting device assignment to a Confidential guest. 

NOTE: IOMTT can also be sufficient for protecting Root devices in the sense that M-mode can enforce that its own resources are never assigned to another domain. Use of IOPMP or similar still adds further protections. For example, a system may require that Root devices cannot be used to access memory assigned to Confidential domain.

==== System integration

In the case of a confidential compute system, the number and make-up of supervisor domains can be known, and a simple convention can be used for common identification of Normal, Confidential, and Root domains across multiple Harts in a system. 

System integration in this context involves providing _security attributes_ on the interconnect, tagging all transactions (CPU or system agent initiated). 

Possible use cases include:

* Tweaking cryptographic memory protection (uniqueness)
* Tagging in cache coherent memory subsystems
* Device assignment (IOPMP/IOMTT integration)

For some use cases security attributes can be extended to reflect finer granularity, for example for cryptographic memory protection. For example, derived from MTT dynamic PMA (svpam).

==== Trusted device assignment

==== Debug, QoS and Performance Monitoring

=== Additional examples

(Variations on the above)

Android pKVM
